# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Project Overview

Production-grade Rust authentication service using Axum, Tokio, Diesel (PostgreSQL), and JWT (HS256). Supports both local HTTP server and AWS Lambda deployment via `lambda_http`. The service handles user authentication, password hashing with bcrypt, JWT generation/validation, and authorization primitives.

## Essential Commands

### Local Development
```bash
# Start local stack (app + PostgreSQL)
make local

# Start in background
make local-detached

# Stop all containers
make stop

# Run database migrations
make migrate

# Revert last migration
make revert

# Run all tests
make test

# Run specific test
make test t=test_name

# Build the project
cargo build

# Run locally (requires PostgreSQL and env vars)
cargo run

# Format and lint
cargo fmt
cargo clippy --all-targets --all-features -- -D warnings
```

### AWS Lambda Deployment
```bash
# Create Lambda infrastructure (first time only)
make deploy-create-stack

# Complete deployment pipeline (build + push + update)
make deploy

# Update Lambda without rebuilding Docker image
make deploy-only

# View Lambda logs in real-time
make deploy-logs

# Show Lambda stack outputs and status
make deploy-status
```

### Database Operations
```bash
# Setup database and run migrations
diesel setup
diesel migration run

# Revert last migration
diesel migration revert

# Open PostgreSQL shell
make db-shell

# Reset database (WARNING: deletes all data)
make db-reset
```

## Architecture

### Layered Design (Mandatory)

The codebase follows strict layering to separate concerns:

1. **HTTP Layer** (`src/handlers/`, `src/app.rs`)
   - Axum route handlers are thin - they ONLY validate input, call services, and map errors to HTTP responses
   - NO business logic in handlers
   - Request/response types in `src/api/` module

2. **Service Layer** (`src/auth/services.rs`)
   - ALL business logic and authentication flows live here
   - JWT creation/validation centralized in `src/auth/jwt.rs`
   - Password hashing/verification centralized in `src/auth/password.rs`
   - Services coordinate between repositories and domain logic

3. **Persistence Layer** (`src/db/`)
   - All database access isolated in `src/db/repositories/`
   - NO Diesel queries outside repositories
   - Models in `src/db/models/`
   - Schema in `src/db/schema.rs` (generated by Diesel)
   - Connection pooling via r2d2 in `src/db/connection.rs`

### API Types Module (`src/api/`)

The `src/api/` module contains all public API types designed for reusability. This module is organized to potentially be extracted as a separate client SDK crate:

- `requests.rs` - Request DTOs (RegisterRequest, LoginRequest, etc.)
- `responses.rs` - Response DTOs (UserResponse, LoginResponse, etc.)
- `error.rs` - Public error format (ErrorResponse)
- `result.rs` - Generic response wrapper (AppResponse<T>)

All handlers should use `AppResponse<T>` for consistent response formatting:
```rust
// 200 OK
Ok(AppResponse::ok(data))

// 201 Created
Ok(AppResponse::created(data))

// 204 No Content
Ok(AppResponse::no_content())

// With custom headers
Ok(AppResponse::ok(data).with_headers(headers))
```

### Key Modules

- **`src/auth/jwt.rs`** - JWT creation, validation, claims handling (HS256 with jsonwebtoken)
- **`src/auth/password.rs`** - bcrypt hashing and verification
- **`src/auth/services.rs`** - Authentication and authorization services
- **`src/auth/extractors.rs`** - Axum extractors for JWT validation
- **`src/error.rs`** - Application-wide error types and HTTP mapping
- **`src/app.rs`** - Router setup, middleware configuration (CORS, tracing)
- **`src/main.rs`** - Entrypoint; selects execution mode (local vs Lambda)

## Configuration

Environment variables required:

```env
# App
APP_ENV=development
SERVER_HOST=0.0.0.0
SERVER_PORT=8080
RUST_LOG=debug

# Database
DATABASE_URL=postgres://postgres:postgres@auth_db:5432/auth_db
DB_POOL_MAX_SIZE=15

# CORS
CORS_ALLOWED_ORIGINS=http://localhost:3000,http://127.0.0.1:3000
CORS_ALLOWED_METHODS=GET,POST,PUT,DELETE

# JWT (HS256)
JWT_SECRET=your_secret_key_here

# Password
BCRYPT_COST=12
```

## Code Style & Rules

### Mandatory Architecture Rules

- HTTP handlers must be thin (no business logic)
- Core logic lives in `src/auth/services.rs`
- Database access isolated in `src/db/repositories/`
- JWT logic centralized in `src/auth/jwt.rs`
- Password hashing centralized in `src/auth/password.rs`
- NO global mutable state
- Secrets and keys are NEVER hardcoded

### Rust Style

- Idiomatic Rust
- Prefer explicit types over inference in public APIs
- Use `Result<T, E>` consistently
- NEVER use `unwrap()` or `expect()` in production code
- Early returns over nested conditionals
- Functions should be small and single-purpose
- Use `chrono` with UTC only
- UUIDs for identifiers

### Error Handling

- Add context to errors using `anyhow::Context`
- NEVER leak sensitive information in errors (passwords, tokens, keys)
- Map internal errors to appropriate HTTP responses in handlers
- Use explicit domain error types; `anyhow` only at boundaries

### Async & Performance

- All I/O must be async
- NEVER use blocking calls in async contexts
- Use connection pooling (r2d2) correctly
- NO heavy computation in request handlers

### Security

- Always hash passwords with bcrypt
- NEVER log secrets, tokens, or passwords
- JWTs must include expiration (`exp`), issued at (`iat`), and subject (`sub`)
- Validate JWT signature and all claims explicitly
- Prefer deny-by-default authorization logic
- Restrict CORS origins; avoid `*` in production
- Refresh tokens stored as hashes in database
- HttpOnly cookies for refresh token storage

## Testing

Tests are run via Docker Compose to ensure a clean database environment:

```bash
# Run all tests
make test

# Run specific test
make test t=test_login

# Run with more verbose output
make test t=test_name -- --nocapture

# Run tests in watch mode
make test-watch
```

### Testing Guidelines

- Favor unit tests for services and repositories
- Use integration tests for HTTP routes
- Mock database access when possible
- Tests must be deterministic
- Avoid coupling tests to handlers
- Clean up test data after tests (delete created users/tokens)

## Common Workflows

### Adding New Endpoint

1. Create request/response DTOs in `src/api/requests.rs` and `src/api/responses.rs`
2. Implement business logic in `src/auth/services.rs` (or create new service module)
3. If needed, create repository methods in `src/db/repositories/`
4. Create handler in `src/handlers/` - keep it thin, delegate to service
5. Register route in `src/app.rs`
6. Add tests

### Database Schema Changes

1. Create migration: `diesel migration generate migration_name`
2. Write `up.sql` and `down.sql` in `migrations/`
3. Apply migration: `make migrate` (or `diesel migration run`)
4. Update models in `src/db/models/` if needed
5. Update repositories in `src/db/repositories/` if needed
6. Schema in `src/db/schema.rs` is auto-generated by Diesel

### Working with JWT

All JWT operations go through `src/auth/jwt.rs`. Never create or validate JWTs outside this module. The module uses HS256 (HMAC with SHA-256) with a secret key from environment variables.

### Error Mapping

Application errors flow through `src/error.rs` which maps domain errors to HTTP status codes. When adding new error types, ensure proper mapping to HTTP responses and that no sensitive data leaks.

## Execution Modes

The service has two runtime modes selected in `src/main.rs`:

- **Local HTTP Server**: Standard Axum server under Tokio for development (port 3000)
- **AWS Lambda**: Uses `lambda_http` adapter for serverless deployment

Detection is based on `AWS_LAMBDA_FUNCTION_NAME` environment variable.

## Resources

- Health endpoint: `GET /health`
- Postman collection: `postman/AuthManager.postman_collection.json`

## Notes

- This is Rust edition 2024
- The project does NOT provide UI, email workflows, or OAuth/social logins
- Keep queries inside repositories; avoid raw SQL in handlers/services
- Use `tracing` macros (`info!`, `warn!`, `error!`, `instrument`) for logging
- Format: GitHub-flavored markdown when documenting
